"use strict";
/* eslint-disable import/no-nodejs-modules */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveMesh = void 0;
const tslib_1 = require("tslib");
/* eslint-disable dot-notation */
const cluster_1 = tslib_1.__importDefault(require("cluster"));
const os_1 = tslib_1.__importDefault(require("os"));
const dnscache_1 = tslib_1.__importDefault(require("dnscache"));
const uWebSockets_1 = require("graphql-ws/lib/use/uWebSockets");
const open_1 = tslib_1.__importDefault(require("open"));
const cross_helpers_1 = require("@graphql-mesh/cross-helpers");
const http_1 = require("@graphql-mesh/http");
const handleFatalError_js_1 = require("../../handleFatalError.js");
const terminateEvents = ['SIGINT', 'SIGTERM'];
function registerTerminateHandler(callback) {
    for (const eventName of terminateEvents) {
        cross_helpers_1.process.once(eventName, () => callback(eventName));
    }
}
function portSelectorFn(sources, logger) {
    const port = sources.find(source => Boolean(source)) || 4000;
    if (sources.filter(source => Boolean(source)).length > 1) {
        const activeSources = [];
        if (sources[0]) {
            activeSources.push('CLI');
        }
        if (sources[1]) {
            activeSources.push('serve configuration');
        }
        if (sources[2]) {
            activeSources.push('environment variable');
        }
        logger.warn(`Multiple ports specified (${activeSources.join(', ')}), using ${port}`);
    }
    return port;
}
async function serveMesh({ baseDir, argsPort, getBuiltMesh, logger, rawServeConfig = {}, playgroundTitle, }, cliParams) {
    const { fork: configFork = cross_helpers_1.process.env.NODE_ENV?.toLowerCase() === 'production', port: configPort, hostname = os_1.default.platform() === 'win32' ||
        // is WSL?
        os_1.default.release().toLowerCase().includes('microsoft')
        ? '127.0.0.1'
        : '0.0.0.0', sslCredentials, endpoint: graphqlPath = '/graphql', browser = cross_helpers_1.process.env.NODE_ENV?.toLowerCase() !== 'production',
    // TODO
    // trustProxy = 'loopback',
     } = rawServeConfig;
    const port = portSelectorFn([argsPort, parseInt(configPort?.toString()), parseInt(cross_helpers_1.process.env.PORT)], logger);
    let forkNum;
    const envFork = cross_helpers_1.process.env.FORK;
    let defaultForkNum = 0;
    try {
        defaultForkNum = os_1.default.availableParallelism();
    }
    catch (e) {
        try {
            defaultForkNum = os_1.default.cpus().length;
        }
        catch (e) {
            // ignore
        }
    }
    if (envFork != null) {
        if (envFork === 'false' || envFork === '0') {
            forkNum = 0;
        }
        else if (envFork === 'true') {
            forkNum = defaultForkNum;
        }
        else {
            forkNum = parseInt(envFork);
        }
    }
    else if (configFork != null) {
        if (typeof configFork === 'boolean') {
            forkNum = configFork ? defaultForkNum : 0;
        }
        else {
            forkNum = configFork;
        }
    }
    const protocol = sslCredentials ? 'https' : 'http';
    const serverUrl = `${protocol}://${hostname}:${port}`;
    if (!playgroundTitle) {
        playgroundTitle = rawServeConfig?.playgroundTitle || cliParams.playgroundTitle;
    }
    if (!cluster_1.default.isWorker && forkNum > 0) {
        for (let i = 0; i < forkNum; i++) {
            const worker = cluster_1.default.fork();
            registerTerminateHandler(eventName => worker.kill(eventName));
        }
        logger.info(`${cliParams.serveMessage}: ${serverUrl} in ${forkNum} forks`);
    }
    else {
        if (cluster_1.default.isWorker) {
            logger = logger.child(`Worker ${cluster_1.default.worker.id}`);
        }
        logger.info(`Starting GraphQL Mesh...`);
        const mesh$ = getBuiltMesh()
            .then(async (mesh) => {
            if (mesh.schema.getType('BigInt')) {
                await Promise.resolve().then(() => tslib_1.__importStar(require('json-bigint-patch')));
            }
            (0, dnscache_1.default)({
                enable: true,
                cache: function CacheCtor({ ttl }) {
                    return {
                        get: (key, callback) => mesh.cache
                            .get(key)
                            .then(value => callback(null, value))
                            .catch(e => callback(e)),
                        set: (key, value, callback) => mesh.cache
                            .set(key, value, { ttl })
                            .then(() => callback())
                            .catch(e => callback(e)),
                    };
                },
            });
            logger.info(`${cliParams.serveMessage}: ${serverUrl}`);
            registerTerminateHandler(eventName => {
                const eventLogger = logger.child(`${eventName}  ðŸ’€`);
                eventLogger.info(`Destroying GraphQL Mesh...`);
                mesh.destroy();
            });
            return mesh;
        })
            .catch(e => (0, handleFatalError_js_1.handleFatalError)(e, logger));
        let uWebSocketsApp;
        const meshHTTPHandler = (0, http_1.createMeshHTTPHandler)({
            baseDir,
            getBuiltMesh: () => mesh$,
            rawServeConfig,
            playgroundTitle,
        });
        if (sslCredentials) {
            const { SSLApp } = await Promise.resolve().then(() => tslib_1.__importStar(require('uWebSockets.js')));
            uWebSocketsApp = SSLApp({
                key_file_name: sslCredentials.key,
                cert_file_name: sslCredentials.cert,
            });
        }
        else {
            const { App } = await Promise.resolve().then(() => tslib_1.__importStar(require('uWebSockets.js')));
            uWebSocketsApp = App();
        }
        uWebSocketsApp.any('/*', meshHTTPHandler);
        const wsHandler = (0, uWebSockets_1.makeBehavior)({
            execute: args => args.rootValue.execute(args),
            subscribe: args => args.rootValue.subscribe(args),
            onSubscribe: async (ctx, msg) => {
                const { getEnveloped } = await mesh$;
                const { schema, execute, subscribe, contextFactory, parse, validate } = getEnveloped(ctx);
                const args = {
                    schema,
                    operationName: msg.payload.operationName,
                    document: parse(msg.payload.query),
                    variableValues: msg.payload.variables,
                    contextValue: await contextFactory(),
                    rootValue: {
                        execute,
                        subscribe,
                    },
                };
                const errors = validate(args.schema, args.document);
                if (errors.length)
                    return errors;
                return args;
            },
        });
        uWebSocketsApp.ws(graphqlPath, wsHandler);
        uWebSocketsApp.listen(hostname, port, listenSocket => {
            registerTerminateHandler(async (eventName) => {
                const eventLogger = logger.child(`${eventName}  ðŸ’€`);
                eventLogger.debug(`Stopping HTTP Server`);
                // eslint-disable-next-line camelcase
                const { us_listen_socket_close } = await Promise.resolve().then(() => tslib_1.__importStar(require('uWebSockets.js')));
                us_listen_socket_close(listenSocket);
                eventLogger.debug(`HTTP Server has been stopped`);
            });
            if (browser) {
                (0, open_1.default)(serverUrl.replace('0.0.0.0', 'localhost'), typeof browser === 'string' ? { app: browser } : undefined).catch(() => { });
            }
        });
        return mesh$.then(mesh => ({
            mesh,
            httpServer: uWebSocketsApp,
            logger,
        }));
    }
    return null;
}
exports.serveMesh = serveMesh;
