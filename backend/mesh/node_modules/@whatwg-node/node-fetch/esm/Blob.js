/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */
import { PonyfillReadableStream } from './ReadableStream.js';
import { isArrayBufferView } from './utils.js';
function getBlobPartAsBuffer(blobPart) {
    if (typeof blobPart === 'string') {
        return Buffer.from(blobPart);
    }
    else if (Buffer.isBuffer(blobPart)) {
        return blobPart;
    }
    else if (isArrayBufferView(blobPart)) {
        return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    }
    else {
        return Buffer.from(blobPart);
    }
}
function isBlob(obj) {
    return obj != null && obj.arrayBuffer != null;
}
// Will be removed after v14 reaches EOL
// Needed because v14 doesn't have .stream() implemented
export class PonyfillBlob {
    constructor(blobParts, options) {
        this.blobParts = blobParts;
        this.type = options?.type || 'application/octet-stream';
        this.encoding = options?.encoding || 'utf8';
    }
    async buffer() {
        const bufferChunks = [];
        for (const blobPart of this.blobParts) {
            if (isBlob(blobPart)) {
                const arrayBuf = await blobPart.arrayBuffer();
                const buf = Buffer.from(arrayBuf, undefined, blobPart.size);
                bufferChunks.push(buf);
            }
            else {
                const buf = getBlobPartAsBuffer(blobPart);
                bufferChunks.push(buf);
            }
        }
        return Buffer.concat(bufferChunks);
    }
    arrayBuffer() {
        return this.buffer().then(buf => buf.buffer);
    }
    async text() {
        let text = '';
        for (const blobPart of this.blobParts) {
            if (typeof blobPart === 'string') {
                text += blobPart;
            }
            else if (isBlob(blobPart)) {
                text += await blobPart.text();
            }
            else {
                const buf = getBlobPartAsBuffer(blobPart);
                text += buf.toString(this.encoding);
            }
        }
        return text;
    }
    get size() {
        let size = 0;
        for (const blobPart of this.blobParts) {
            if (typeof blobPart === 'string') {
                size += Buffer.byteLength(blobPart);
            }
            else if (isBlob(blobPart)) {
                size += blobPart.size;
            }
            else if (isArrayBufferView(blobPart)) {
                size += blobPart.byteLength;
            }
        }
        return size;
    }
    stream() {
        let partQueue = [];
        return new PonyfillReadableStream({
            start: controller => {
                partQueue = [...this.blobParts];
                if (partQueue.length === 0) {
                    controller.close();
                }
            },
            pull: controller => {
                const blobPart = partQueue.pop();
                if (blobPart) {
                    if (isBlob(blobPart)) {
                        return blobPart.arrayBuffer().then(arrayBuffer => {
                            const buf = Buffer.from(arrayBuffer, undefined, blobPart.size);
                            controller.enqueue(buf);
                        });
                    }
                    else {
                        const buf = getBlobPartAsBuffer(blobPart);
                        controller.enqueue(buf);
                    }
                }
                else {
                    controller.close();
                }
            },
        });
    }
    slice() {
        throw new Error('Not implemented');
    }
}
